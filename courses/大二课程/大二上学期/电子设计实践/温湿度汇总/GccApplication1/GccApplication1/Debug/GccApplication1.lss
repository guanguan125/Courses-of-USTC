
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000386  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000018  00800060  00000386  000003fa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  00000412  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000444  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 000000a8  00000000  00000000  00000480  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000f88  00000000  00000000  00000528  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000006fc  00000000  00000000  000014b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000006a7  00000000  00000000  00001bac  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000198  00000000  00000000  00002254  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000471  00000000  00000000  000023ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000008b5  00000000  00000000  0000285d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000098  00000000  00000000  00003112  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	24 c0       	rjmp	.+72     	; 0x4c <__bad_interrupt>
   4:	23 c0       	rjmp	.+70     	; 0x4c <__bad_interrupt>
   6:	22 c0       	rjmp	.+68     	; 0x4c <__bad_interrupt>
   8:	21 c0       	rjmp	.+66     	; 0x4c <__bad_interrupt>
   a:	20 c0       	rjmp	.+64     	; 0x4c <__bad_interrupt>
   c:	1f c0       	rjmp	.+62     	; 0x4c <__bad_interrupt>
   e:	1e c0       	rjmp	.+60     	; 0x4c <__bad_interrupt>
  10:	1d c0       	rjmp	.+58     	; 0x4c <__bad_interrupt>
  12:	1c c0       	rjmp	.+56     	; 0x4c <__bad_interrupt>
  14:	1b c0       	rjmp	.+54     	; 0x4c <__bad_interrupt>
  16:	1a c0       	rjmp	.+52     	; 0x4c <__bad_interrupt>
  18:	19 c0       	rjmp	.+50     	; 0x4c <__bad_interrupt>
  1a:	18 c0       	rjmp	.+48     	; 0x4c <__bad_interrupt>
  1c:	17 c0       	rjmp	.+46     	; 0x4c <__bad_interrupt>
  1e:	16 c0       	rjmp	.+44     	; 0x4c <__bad_interrupt>
  20:	15 c0       	rjmp	.+42     	; 0x4c <__bad_interrupt>
  22:	14 c0       	rjmp	.+40     	; 0x4c <__bad_interrupt>
  24:	13 c0       	rjmp	.+38     	; 0x4c <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	10 e0       	ldi	r17, 0x00	; 0
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e6 e8       	ldi	r30, 0x86	; 134
  3a:	f3 e0       	ldi	r31, 0x03	; 3
  3c:	02 c0       	rjmp	.+4      	; 0x42 <__SREG__+0x3>
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0
  42:	a8 37       	cpi	r26, 0x78	; 120
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <__SP_H__>
  48:	0d d1       	rcall	.+538    	; 0x264 <main>
  4a:	9b c1       	rjmp	.+822    	; 0x382 <_exit>

0000004c <__bad_interrupt>:
  4c:	d9 cf       	rjmp	.-78     	; 0x0 <__vectors>

0000004e <TWI_Init>:
}unsigned char TWI_Get_State_Info(void)
{
	unsigned char uc_status;
	uc_status = TWSR & 0xf8;
	return uc_status;
}
  4e:	11 b8       	out	0x01, r1	; 1
  50:	82 e0       	ldi	r24, 0x02	; 2
  52:	80 b9       	out	0x00, r24	; 0
  54:	84 e0       	ldi	r24, 0x04	; 4
  56:	86 bf       	out	0x36, r24	; 54
  58:	08 95       	ret

0000005a <TWI_Start>:
  5a:	84 ea       	ldi	r24, 0xA4	; 164
  5c:	86 bf       	out	0x36, r24	; 54
  5e:	06 b6       	in	r0, 0x36	; 54
  60:	07 fe       	sbrs	r0, 7
  62:	fd cf       	rjmp	.-6      	; 0x5e <TWI_Start+0x4>
  64:	08 95       	ret

00000066 <TWI_Write>:
  66:	83 b9       	out	0x03, r24	; 3
  68:	84 e8       	ldi	r24, 0x84	; 132
  6a:	86 bf       	out	0x36, r24	; 54
  6c:	06 b6       	in	r0, 0x36	; 54
  6e:	07 fe       	sbrs	r0, 7
  70:	fd cf       	rjmp	.-6      	; 0x6c <TWI_Write+0x6>
  72:	08 95       	ret

00000074 <TWI_Write_LCD>:
#define LCD_RW 0x02 //PCF8574-P1）控制LCD1602的RW管脚
#define LCD_E 0x04 //PCF8574-P2）控制LCD1602的E管脚
#define LCD_BACKLIGHTON 0x08 //PCF8574-P3控制LCD1602的K管脚
#define LCD_SLAVE_ADDRESS 0x27 //从机地址PCF8574(A2-0:111)
unsigned char TWI_Write_LCD(unsigned char uc_data)
{ TWI_Start();//发送START信号
  74:	cf 93       	push	r28
  76:	c8 2f       	mov	r28, r24
  78:	f0 df       	rcall	.-32     	; 0x5a <TWI_Start>
	while(!(TWCR &(1<<TWINT)));//等待接收数据
	return TWDR;//返回接收到的数据
}unsigned char TWI_Get_State_Info(void)
{
	unsigned char uc_status;
	uc_status = TWSR & 0xf8;
  7a:	81 b1       	in	r24, 0x01	; 1
	if(TWI_Get_State_Info()!=TW_START) return 0;//不成功
  7c:	88 7f       	andi	r24, 0xF8	; 248
  7e:	88 30       	cpi	r24, 0x08	; 8
  80:	89 f4       	brne	.+34     	; 0xa4 <TWI_Write_LCD+0x30>
	TWI_Write(LCD_SLAVE_ADDRESS<<1|TW_WRITE); //发送SLA+W
  82:	8e e4       	ldi	r24, 0x4E	; 78
  84:	f0 df       	rcall	.-32     	; 0x66 <TWI_Write>
  86:	81 b1       	in	r24, 0x01	; 1
	if(TWI_Get_State_Info()!=TW_MT_SLA_ACK)return 0;//不成功
  88:	88 7f       	andi	r24, 0xF8	; 248
  8a:	88 31       	cpi	r24, 0x18	; 24
  8c:	69 f4       	brne	.+26     	; 0xa8 <TWI_Write_LCD+0x34>
	TWI_Write(uc_data|LCD_BACKLIGHTON);//发送数据+背光常开
  8e:	8c 2f       	mov	r24, r28
  90:	88 60       	ori	r24, 0x08	; 8
  92:	e9 df       	rcall	.-46     	; 0x66 <TWI_Write>
  94:	81 b1       	in	r24, 0x01	; 1
	if(TWI_Get_State_Info()!=TW_MT_DATA_ACK)return 0;//不成功
  96:	88 7f       	andi	r24, 0xF8	; 248
  98:	88 32       	cpi	r24, 0x28	; 40
  9a:	41 f4       	brne	.+16     	; 0xac <TWI_Write_LCD+0x38>
void TWI_Start(void)//发送Start信号，开始本次TWI通信
{ TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);//发送Start信号
	while(!(TWCR &(1<<TWINT)));//等待Start信号发出
}
void TWI_Stop(void)//发送Stop信号，结束本次TWI通信
{ TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);//发送Stop信号
  9c:	84 e9       	ldi	r24, 0x94	; 148
  9e:	86 bf       	out	0x36, r24	; 54
	TWI_Stop();
	return 1;//成功
  a0:	81 e0       	ldi	r24, 0x01	; 1
  a2:	05 c0       	rjmp	.+10     	; 0xae <TWI_Write_LCD+0x3a>
#define LCD_E 0x04 //PCF8574-P2）控制LCD1602的E管脚
#define LCD_BACKLIGHTON 0x08 //PCF8574-P3控制LCD1602的K管脚
#define LCD_SLAVE_ADDRESS 0x27 //从机地址PCF8574(A2-0:111)
unsigned char TWI_Write_LCD(unsigned char uc_data)
{ TWI_Start();//发送START信号
	if(TWI_Get_State_Info()!=TW_START) return 0;//不成功
  a4:	80 e0       	ldi	r24, 0x00	; 0
  a6:	03 c0       	rjmp	.+6      	; 0xae <TWI_Write_LCD+0x3a>
	TWI_Write(LCD_SLAVE_ADDRESS<<1|TW_WRITE); //发送SLA+W
	if(TWI_Get_State_Info()!=TW_MT_SLA_ACK)return 0;//不成功
  a8:	80 e0       	ldi	r24, 0x00	; 0
  aa:	01 c0       	rjmp	.+2      	; 0xae <TWI_Write_LCD+0x3a>
	TWI_Write(uc_data|LCD_BACKLIGHTON);//发送数据+背光常开
	if(TWI_Get_State_Info()!=TW_MT_DATA_ACK)return 0;//不成功
  ac:	80 e0       	ldi	r24, 0x00	; 0
	TWI_Stop();
	return 1;//成功
}
  ae:	cf 91       	pop	r28
  b0:	08 95       	ret

000000b2 <LCD_4Bit_Write>:
void LCD_4Bit_Write(unsigned char uc_data)//4位方式写PCF8574
{ TWI_Write_LCD(uc_data);//数据送出，E=0
  b2:	cf 93       	push	r28
  b4:	c8 2f       	mov	r28, r24
  b6:	de df       	rcall	.-68     	; 0x74 <TWI_Write_LCD>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  b8:	00 00       	nop
	_delay_us(1);//保持
	TWI_Write_LCD(uc_data|LCD_E);//数据送出，E=1
  ba:	8c 2f       	mov	r24, r28
  bc:	84 60       	ori	r24, 0x04	; 4
  be:	da df       	rcall	.-76     	; 0x74 <TWI_Write_LCD>
  c0:	00 00       	nop
	_delay_us(1);//保持
	TWI_Write_LCD(uc_data & (~LCD_E));//数据送出，E=0
  c2:	8c 2f       	mov	r24, r28
  c4:	8b 7f       	andi	r24, 0xFB	; 251
  c6:	d6 df       	rcall	.-84     	; 0x74 <TWI_Write_LCD>
  c8:	80 e1       	ldi	r24, 0x10	; 16
  ca:	8a 95       	dec	r24
  cc:	f1 f7       	brne	.-4      	; 0xca <LCD_4Bit_Write+0x18>
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <LCD_4Bit_Write+0x1e>
	_delay_us(50);//等待数据传输结束
}
  d0:	cf 91       	pop	r28
  d2:	08 95       	ret

000000d4 <LCD_8Bit_Write>:
void LCD_8Bit_Write(unsigned char uc_data,unsigned char uc_mode)
//2次4位数据传输方式写PCF9574,uc_mode:0-命令,1-数据
{ unsigned char high4bit = uc_data & 0xf0;
  d4:	cf 93       	push	r28
  d6:	df 93       	push	r29
  d8:	c8 2f       	mov	r28, r24
  da:	d6 2f       	mov	r29, r22
	unsigned char low4bit = (uc_data<<4)&0xf0;
	LCD_4Bit_Write(high4bit|uc_mode);//先发送高4位
  dc:	80 7f       	andi	r24, 0xF0	; 240
  de:	86 2b       	or	r24, r22
  e0:	e8 df       	rcall	.-48     	; 0xb2 <LCD_4Bit_Write>
	LCD_4Bit_Write(low4bit|uc_mode);//再发送低4位
  e2:	20 e1       	ldi	r18, 0x10	; 16
  e4:	c2 9f       	mul	r28, r18
  e6:	c0 01       	movw	r24, r0
  e8:	11 24       	eor	r1, r1
  ea:	8d 2b       	or	r24, r29
  ec:	e2 df       	rcall	.-60     	; 0xb2 <LCD_4Bit_Write>
}
  ee:	df 91       	pop	r29
  f0:	cf 91       	pop	r28
  f2:	08 95       	ret

000000f4 <LCD_Init>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  f4:	83 ed       	ldi	r24, 0xD3	; 211
  f6:	90 e3       	ldi	r25, 0x30	; 48
  f8:	01 97       	sbiw	r24, 0x01	; 1
  fa:	f1 f7       	brne	.-4      	; 0xf8 <LCD_Init+0x4>
  fc:	00 c0       	rjmp	.+0      	; 0xfe <LCD_Init+0xa>
  fe:	00 00       	nop
void LCD_Init()//初始化LCD1602
{ _delay_ms(50);//上电后至少再等40ms
	LCD_4Bit_Write(0x30); //在默认8位接口，试着进入4位接口模式
 100:	80 e3       	ldi	r24, 0x30	; 48
 102:	d7 df       	rcall	.-82     	; 0xb2 <LCD_4Bit_Write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 104:	84 e6       	ldi	r24, 0x64	; 100
 106:	94 e0       	ldi	r25, 0x04	; 4
 108:	01 97       	sbiw	r24, 0x01	; 1
 10a:	f1 f7       	brne	.-4      	; 0x108 <LCD_Init+0x14>
 10c:	00 c0       	rjmp	.+0      	; 0x10e <LCD_Init+0x1a>
 10e:	00 00       	nop
	_delay_us(4500);//等待至少4.5ms
	LCD_4Bit_Write(0x30); _delay_us(4500);//等待至少4.5ms
 110:	80 e3       	ldi	r24, 0x30	; 48
 112:	cf df       	rcall	.-98     	; 0xb2 <LCD_4Bit_Write>
 114:	84 e6       	ldi	r24, 0x64	; 100
 116:	94 e0       	ldi	r25, 0x04	; 4
 118:	01 97       	sbiw	r24, 0x01	; 1
 11a:	f1 f7       	brne	.-4      	; 0x118 <LCD_Init+0x24>
 11c:	00 c0       	rjmp	.+0      	; 0x11e <LCD_Init+0x2a>
 11e:	00 00       	nop
	LCD_4Bit_Write(0x30); _delay_us(150);//等待至少150us
 120:	80 e3       	ldi	r24, 0x30	; 48
 122:	c7 df       	rcall	.-114    	; 0xb2 <LCD_4Bit_Write>
 124:	92 e3       	ldi	r25, 0x32	; 50
 126:	9a 95       	dec	r25
 128:	f1 f7       	brne	.-4      	; 0x126 <LCD_Init+0x32>
	LCD_4Bit_Write(0x20);//进入4位接口模式
 12a:	80 e2       	ldi	r24, 0x20	; 32
 12c:	c2 df       	rcall	.-124    	; 0xb2 <LCD_4Bit_Write>
	//设置模式，显示，点数等
	LCD_8Bit_Write(LCD_FUNCTIONSET|LCD_4BITMODE|LCD_2LINE|LCD_5X8DOTS,
 12e:	60 e0       	ldi	r22, 0x00	; 0
 130:	88 e2       	ldi	r24, 0x28	; 40
 132:	d0 df       	rcall	.-96     	; 0xd4 <LCD_8Bit_Write>
	0);
	LCD_8Bit_Write(LCD_DISPLAYCONTROL|LCD_DISPLAYON,0);//显示
 134:	60 e0       	ldi	r22, 0x00	; 0
 136:	8c e0       	ldi	r24, 0x0C	; 12
 138:	cd df       	rcall	.-102    	; 0xd4 <LCD_8Bit_Write>
	LCD_8Bit_Write(LCD_CLEARDISPLAY,0); _delay_us(2000);//等待
 13a:	60 e0       	ldi	r22, 0x00	; 0
 13c:	81 e0       	ldi	r24, 0x01	; 1
 13e:	ca df       	rcall	.-108    	; 0xd4 <LCD_8Bit_Write>
 140:	83 ef       	ldi	r24, 0xF3	; 243
 142:	91 e0       	ldi	r25, 0x01	; 1
 144:	01 97       	sbiw	r24, 0x01	; 1
 146:	f1 f7       	brne	.-4      	; 0x144 <LCD_Init+0x50>
 148:	00 c0       	rjmp	.+0      	; 0x14a <LCD_Init+0x56>
 14a:	00 00       	nop
	LCD_8Bit_Write(LCD_ENTRYMODESET|LCD_ENTRYINC,0);//显示左移(递增)
 14c:	60 e0       	ldi	r22, 0x00	; 0
 14e:	86 e0       	ldi	r24, 0x06	; 6
 150:	c1 df       	rcall	.-126    	; 0xd4 <LCD_8Bit_Write>
	LCD_8Bit_Write(LCD_RETURNHOME,0);//返回原点
 152:	60 e0       	ldi	r22, 0x00	; 0
 154:	82 e0       	ldi	r24, 0x02	; 2
 156:	be df       	rcall	.-132    	; 0xd4 <LCD_8Bit_Write>
 158:	83 ef       	ldi	r24, 0xF3	; 243
 15a:	91 e0       	ldi	r25, 0x01	; 1
 15c:	01 97       	sbiw	r24, 0x01	; 1
 15e:	f1 f7       	brne	.-4      	; 0x15c <LCD_Init+0x68>
 160:	00 c0       	rjmp	.+0      	; 0x162 <LCD_Init+0x6e>
 162:	00 00       	nop
 164:	08 95       	ret

00000166 <LCD_Set_Cursor_Location>:
	_delay_us(2000);//等待
}
void LCD_Set_Cursor_Location(unsigned char row,unsigned char col)
//设置光标位置,row:0~1,col:0~39
{ unsigned char offset[]={0x0,0x40}; LCD_8Bit_Write(LCD_SETDDRAMADDR|(col+offset[row]),0);
 166:	cf 93       	push	r28
 168:	df 93       	push	r29
 16a:	00 d0       	rcall	.+0      	; 0x16c <LCD_Set_Cursor_Location+0x6>
 16c:	cd b7       	in	r28, 0x3d	; 61
 16e:	de b7       	in	r29, 0x3e	; 62
 170:	19 82       	std	Y+1, r1	; 0x01
 172:	90 e4       	ldi	r25, 0x40	; 64
 174:	9a 83       	std	Y+2, r25	; 0x02
 176:	fe 01       	movw	r30, r28
 178:	e8 0f       	add	r30, r24
 17a:	f1 1d       	adc	r31, r1
 17c:	81 81       	ldd	r24, Z+1	; 0x01
 17e:	86 0f       	add	r24, r22
 180:	60 e0       	ldi	r22, 0x00	; 0
 182:	80 68       	ori	r24, 0x80	; 128
 184:	a7 df       	rcall	.-178    	; 0xd4 <LCD_8Bit_Write>
}
 186:	0f 90       	pop	r0
 188:	0f 90       	pop	r0
 18a:	df 91       	pop	r29
 18c:	cf 91       	pop	r28
 18e:	08 95       	ret

00000190 <LCD_Write_NewChar>:
void LCD_Write_NewChar(char c_data)//在当前位置显示
{ LCD_8Bit_Write(c_data,1);
 190:	61 e0       	ldi	r22, 0x01	; 1
 192:	a0 df       	rcall	.-192    	; 0xd4 <LCD_8Bit_Write>
 194:	08 95       	ret

00000196 <LCD_Write_Char>:
}
void LCD_Write_Char(unsigned char row,unsigned char col,char c_data)
//在指定位置显示
{ LCD_Set_Cursor_Location(row,col); LCD_8Bit_Write(c_data,1);
 196:	cf 93       	push	r28
 198:	c4 2f       	mov	r28, r20
 19a:	e5 df       	rcall	.-54     	; 0x166 <LCD_Set_Cursor_Location>
 19c:	61 e0       	ldi	r22, 0x01	; 1
 19e:	8c 2f       	mov	r24, r28
 1a0:	99 df       	rcall	.-206    	; 0xd4 <LCD_8Bit_Write>
}
 1a2:	cf 91       	pop	r28
 1a4:	08 95       	ret

000001a6 <LCD_Write_String>:
void LCD_Write_String(unsigned char row,unsigned char col,const char *pStr)
//在指定位置显示串
{
 1a6:	cf 93       	push	r28
 1a8:	df 93       	push	r29
 1aa:	ea 01       	movw	r28, r20
	LCD_Set_Cursor_Location(row,col);
 1ac:	dc df       	rcall	.-72     	; 0x166 <LCD_Set_Cursor_Location>
	while((*pStr) != '\0')
 1ae:	88 81       	ld	r24, Y
 1b0:	88 23       	and	r24, r24
 1b2:	31 f0       	breq	.+12     	; 0x1c0 <LCD_Write_String+0x1a>
 1b4:	21 96       	adiw	r28, 0x01	; 1
	{
		LCD_8Bit_Write(*pStr,1);
 1b6:	61 e0       	ldi	r22, 0x01	; 1
 1b8:	8d df       	rcall	.-230    	; 0xd4 <LCD_8Bit_Write>
}
void LCD_Write_String(unsigned char row,unsigned char col,const char *pStr)
//在指定位置显示串
{
	LCD_Set_Cursor_Location(row,col);
	while((*pStr) != '\0')
 1ba:	89 91       	ld	r24, Y+
 1bc:	81 11       	cpse	r24, r1
 1be:	fb cf       	rjmp	.-10     	; 0x1b6 <LCD_Write_String+0x10>
	{
		LCD_8Bit_Write(*pStr,1);
		pStr ++;
	}

}
 1c0:	df 91       	pop	r29
 1c2:	cf 91       	pop	r28
 1c4:	08 95       	ret

000001c6 <byteReadDHT11>:
#define F_CPU 1000000UL
#endif
#include <avr/io.h>
#include <util/delay.h>
unsigned char byteReadDHT11(void) //从DHT11读取一个字节的数据
{ unsigned char oneBit,oneByte=0;//每次接收1位，最后完成8位接收并返回
 1c6:	38 e0       	ldi	r19, 0x08	; 8
 1c8:	80 e0       	ldi	r24, 0x00	; 0
 1ca:	03 c0       	rjmp	.+6      	; 0x1d2 <byteReadDHT11+0xc>
 1cc:	91 50       	subi	r25, 0x01	; 1
	for(i=0;i<8;i++)//接收8位数据，先接收的是最高位
	{//1bit由50us的低电平开始，后跟26~28us的高电平为0，70us的高电平为1
		uc_cnt = 1;//超时计数初值，统计50us低电平
		while((PIND & (1<<PIND7))==0)//在50us的低电平
		{ uc_cnt++;//超时计数
		if(uc_cnt==0)break;/*计数溢出：超时，跳过*/}
 1ce:	11 f4       	brne	.+4      	; 0x1d4 <byteReadDHT11+0xe>
 1d0:	03 c0       	rjmp	.+6      	; 0x1d8 <byteReadDHT11+0x12>
#define F_CPU 1000000UL
#endif
#include <avr/io.h>
#include <util/delay.h>
unsigned char byteReadDHT11(void) //从DHT11读取一个字节的数据
{ unsigned char oneBit,oneByte=0;//每次接收1位，最后完成8位接收并返回
 1d2:	9f ef       	ldi	r25, 0xFF	; 255
	unsigned char i,uc_cnt;//循环变量，超时计数（脉冲宽度统计）
	for(i=0;i<8;i++)//接收8位数据，先接收的是最高位
	{//1bit由50us的低电平开始，后跟26~28us的高电平为0，70us的高电平为1
		uc_cnt = 1;//超时计数初值，统计50us低电平
		while((PIND & (1<<PIND7))==0)//在50us的低电平
 1d4:	87 9b       	sbis	0x10, 7	; 16
 1d6:	fa cf       	rjmp	.-12     	; 0x1cc <byteReadDHT11+0x6>
 1d8:	9a e0       	ldi	r25, 0x0A	; 10
 1da:	9a 95       	dec	r25
 1dc:	f1 f7       	brne	.-4      	; 0x1da <byteReadDHT11+0x14>
		{ uc_cnt++;//超时计数
		if(uc_cnt==0)break;/*计数溢出：超时，跳过*/}
		_delay_us(30);//跳过30us的高电平，如还是高电平收到‘1’，否则收到‘0’
		oneBit = 0;//假定收到‘0’
		if((PIND & (1<<PIND7))!=0)oneBit = 1;//还是高电平，收到‘1’
 1de:	20 b3       	in	r18, 0x10	; 16
		uc_cnt = 1;//超时计数初值，统计50us低电平
		while((PIND & (1<<PIND7))==0)//在50us的低电平
		{ uc_cnt++;//超时计数
		if(uc_cnt==0)break;/*计数溢出：超时，跳过*/}
		_delay_us(30);//跳过30us的高电平，如还是高电平收到‘1’，否则收到‘0’
		oneBit = 0;//假定收到‘0’
 1e0:	22 1f       	adc	r18, r18
 1e2:	22 27       	eor	r18, r18
 1e4:	22 1f       	adc	r18, r18
		if((PIND & (1<<PIND7))!=0)oneBit = 1;//还是高电平，收到‘1’
		uc_cnt = 1;//超时计数初值，统计70us高电平
		while((PIND & (1<<PIND7))!=0)//在70us的高电平
 1e6:	9f ef       	ldi	r25, 0xFF	; 255
 1e8:	02 c0       	rjmp	.+4      	; 0x1ee <byteReadDHT11+0x28>
 1ea:	91 50       	subi	r25, 0x01	; 1
		{ uc_cnt++; /*超时计数*/if(uc_cnt==0)break;/*计数溢出:超时，跳过*/}
 1ec:	11 f0       	breq	.+4      	; 0x1f2 <byteReadDHT11+0x2c>
		if(uc_cnt==0)break;/*计数溢出：超时，跳过*/}
		_delay_us(30);//跳过30us的高电平，如还是高电平收到‘1’，否则收到‘0’
		oneBit = 0;//假定收到‘0’
		if((PIND & (1<<PIND7))!=0)oneBit = 1;//还是高电平，收到‘1’
		uc_cnt = 1;//超时计数初值，统计70us高电平
		while((PIND & (1<<PIND7))!=0)//在70us的高电平
 1ee:	87 99       	sbic	0x10, 7	; 16
 1f0:	fc cf       	rjmp	.-8      	; 0x1ea <byteReadDHT11+0x24>
		{ uc_cnt++; /*超时计数*/if(uc_cnt==0)break;/*计数溢出:超时，跳过*/}
		oneByte <<=1;//收到1位后，之前收到的为高位，故左移一位
 1f2:	88 0f       	add	r24, r24
	oneByte |=oneBit;/*新收到的合并到字节中*/}
 1f4:	82 2b       	or	r24, r18
 1f6:	31 50       	subi	r19, 0x01	; 1
#include <avr/io.h>
#include <util/delay.h>
unsigned char byteReadDHT11(void) //从DHT11读取一个字节的数据
{ unsigned char oneBit,oneByte=0;//每次接收1位，最后完成8位接收并返回
	unsigned char i,uc_cnt;//循环变量，超时计数（脉冲宽度统计）
	for(i=0;i<8;i++)//接收8位数据，先接收的是最高位
 1f8:	61 f7       	brne	.-40     	; 0x1d2 <byteReadDHT11+0xc>
		while((PIND & (1<<PIND7))!=0)//在70us的高电平
		{ uc_cnt++; /*超时计数*/if(uc_cnt==0)break;/*计数溢出:超时，跳过*/}
		oneByte <<=1;//收到1位后，之前收到的为高位，故左移一位
	oneByte |=oneBit;/*新收到的合并到字节中*/}
	return oneByte; /*返回收到的1字节*/
}
 1fa:	08 95       	ret

000001fc <DHT11_Run>:
void DHT11_Run(unsigned char * uc_data) //与DHT11通信的设置和数据传输等
{ unsigned char uc_cnt;//超时计数（脉冲宽度统计）
 1fc:	0f 93       	push	r16
 1fe:	1f 93       	push	r17
 200:	cf 93       	push	r28
 202:	df 93       	push	r29
 204:	8c 01       	movw	r16, r24
	DDRD |=(1<<DDRD7);//PD7为输出模式
 206:	8f 9a       	sbi	0x11, 7	; 17
	PORTD &=~(1<<PORTD7);/*PD7输出0*/_delay_ms(20);//至少18ms的START信号
 208:	97 98       	cbi	0x12, 7	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 20a:	87 e8       	ldi	r24, 0x87	; 135
 20c:	93 e1       	ldi	r25, 0x13	; 19
 20e:	01 97       	sbiw	r24, 0x01	; 1
 210:	f1 f7       	brne	.-4      	; 0x20e <DHT11_Run+0x12>
 212:	00 c0       	rjmp	.+0      	; 0x214 <DHT11_Run+0x18>
 214:	00 00       	nop
	PORTD |=(1<<PORTD7); /*PD7输出1:20~40us*/_delay_us(20);//20us高电平
 216:	97 9a       	sbi	0x12, 7	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 218:	96 e0       	ldi	r25, 0x06	; 6
 21a:	9a 95       	dec	r25
 21c:	f1 f7       	brne	.-4      	; 0x21a <DHT11_Run+0x1e>
 21e:	00 c0       	rjmp	.+0      	; 0x220 <DHT11_Run+0x24>
	DDRD &=~(1<<DDRD7); /*PD7为输入模式*/_delay_us(20);//等待DHT11响应
 220:	8f 98       	cbi	0x11, 7	; 17
 222:	86 e0       	ldi	r24, 0x06	; 6
 224:	8a 95       	dec	r24
 226:	f1 f7       	brne	.-4      	; 0x224 <DHT11_Run+0x28>
 228:	00 c0       	rjmp	.+0      	; 0x22a <DHT11_Run+0x2e>
	if((PIND &(1<<PIND7))!=0)return;//DHT11没有响应
 22a:	87 99       	sbic	0x10, 7	; 16
 22c:	16 c0       	rjmp	.+44     	; 0x25a <DHT11_Run+0x5e>
 22e:	9f ef       	ldi	r25, 0xFF	; 255
 230:	02 c0       	rjmp	.+4      	; 0x236 <DHT11_Run+0x3a>
 232:	91 50       	subi	r25, 0x01	; 1
	uc_cnt = 1;//超时计数初值，统计80us低电平响应
	while((PIND & (1<<PIND7))==0)//在80us的低电平
	{ uc_cnt++;//超时计数
	if(uc_cnt==0)break;/*计数溢出：超时，跳过*/}
 234:	39 f0       	breq	.+14     	; 0x244 <DHT11_Run+0x48>
	PORTD &=~(1<<PORTD7);/*PD7输出0*/_delay_ms(20);//至少18ms的START信号
	PORTD |=(1<<PORTD7); /*PD7输出1:20~40us*/_delay_us(20);//20us高电平
	DDRD &=~(1<<DDRD7); /*PD7为输入模式*/_delay_us(20);//等待DHT11响应
	if((PIND &(1<<PIND7))!=0)return;//DHT11没有响应
	uc_cnt = 1;//超时计数初值，统计80us低电平响应
	while((PIND & (1<<PIND7))==0)//在80us的低电平
 236:	87 9b       	sbis	0x10, 7	; 16
 238:	fc cf       	rjmp	.-8      	; 0x232 <DHT11_Run+0x36>
 23a:	9f ef       	ldi	r25, 0xFF	; 255
 23c:	04 c0       	rjmp	.+8      	; 0x246 <DHT11_Run+0x4a>
 23e:	91 50       	subi	r25, 0x01	; 1
	{ uc_cnt++;//超时计数
	if(uc_cnt==0)break;/*计数溢出：超时，跳过*/}
	uc_cnt = 1;//超时计数初值，统计80us高电平响应
	while((PIND & (1<<PIND7))!=0)//在80us的高电平
	{ uc_cnt++; /*超时计数*/ if(uc_cnt==0)break; /*计数溢出：超时，跳过*/
 240:	11 f4       	brne	.+4      	; 0x246 <DHT11_Run+0x4a>
 242:	03 c0       	rjmp	.+6      	; 0x24a <DHT11_Run+0x4e>
 244:	9f ef       	ldi	r25, 0xFF	; 255
	uc_cnt = 1;//超时计数初值，统计80us低电平响应
	while((PIND & (1<<PIND7))==0)//在80us的低电平
	{ uc_cnt++;//超时计数
	if(uc_cnt==0)break;/*计数溢出：超时，跳过*/}
	uc_cnt = 1;//超时计数初值，统计80us高电平响应
	while((PIND & (1<<PIND7))!=0)//在80us的高电平
 246:	87 99       	sbic	0x10, 7	; 16
 248:	fa cf       	rjmp	.-12     	; 0x23e <DHT11_Run+0x42>
 24a:	e8 01       	movw	r28, r16
 24c:	0b 5f       	subi	r16, 0xFB	; 251
 24e:	1f 4f       	sbci	r17, 0xFF	; 255
	{ uc_cnt++; /*超时计数*/ if(uc_cnt==0)break; /*计数溢出：超时，跳过*/
	}
	for(uc_cnt=0;uc_cnt<5;uc_cnt++) //接收DHT11发送的40位温湿度数据
	{ uc_data[uc_cnt]=byteReadDHT11();//0-湿度整/小数,温度整/小数,校验-4
 250:	ba df       	rcall	.-140    	; 0x1c6 <byteReadDHT11>
 252:	89 93       	st	Y+, r24
	if(uc_cnt==0)break;/*计数溢出：超时，跳过*/}
	uc_cnt = 1;//超时计数初值，统计80us高电平响应
	while((PIND & (1<<PIND7))!=0)//在80us的高电平
	{ uc_cnt++; /*超时计数*/ if(uc_cnt==0)break; /*计数溢出：超时，跳过*/
	}
	for(uc_cnt=0;uc_cnt<5;uc_cnt++) //接收DHT11发送的40位温湿度数据
 254:	c0 17       	cp	r28, r16
 256:	d1 07       	cpc	r29, r17
 258:	d9 f7       	brne	.-10     	; 0x250 <DHT11_Run+0x54>
	{ uc_data[uc_cnt]=byteReadDHT11();//0-湿度整/小数,温度整/小数,校验-4
	}
}
 25a:	df 91       	pop	r29
 25c:	cf 91       	pop	r28
 25e:	1f 91       	pop	r17
 260:	0f 91       	pop	r16
 262:	08 95       	ret

00000264 <main>:
 */ 
#include <avr/io.h>
#include "twi_lcd.h"
#include "dht11.h"
int main(void)
{
 264:	cf 93       	push	r28
 266:	df 93       	push	r29
 268:	00 d0       	rcall	.+0      	; 0x26a <main+0x6>
 26a:	00 d0       	rcall	.+0      	; 0x26c <main+0x8>
 26c:	1f 92       	push	r1
 26e:	cd b7       	in	r28, 0x3d	; 61
 270:	de b7       	in	r29, 0x3e	; 62
	unsigned char toggle=1,dht11_data[5]={0};
 272:	fe 01       	movw	r30, r28
 274:	31 96       	adiw	r30, 0x01	; 1
 276:	85 e0       	ldi	r24, 0x05	; 5
 278:	df 01       	movw	r26, r30
 27a:	1d 92       	st	X+, r1
 27c:	8a 95       	dec	r24
 27e:	e9 f7       	brne	.-6      	; 0x27a <main+0x16>
	TWI_Init();
 280:	e6 de       	rcall	.-564    	; 0x4e <TWI_Init>
	LCD_Init();
 282:	38 df       	rcall	.-400    	; 0xf4 <LCD_Init>
#include <avr/io.h>
#include "twi_lcd.h"
#include "dht11.h"
int main(void)
{
	unsigned char toggle=1,dht11_data[5]={0};
 284:	11 e0       	ldi	r17, 0x01	; 1
	LCD_Init();
	while (1)
	{ DHT11_Run(dht11_data);
		if(dht11_data[4]==(dht11_data[0]+dht11_data[1]+dht11_data[2]+dht11_data[3]))
		{ LCD_Write_String(0,0,"Temperature:");//
			LCD_Write_NewChar(dht11_data[2]/10%10+0x30);
 286:	0d ec       	ldi	r16, 0xCD	; 205
{
	unsigned char toggle=1,dht11_data[5]={0};
	TWI_Init();
	LCD_Init();
	while (1)
	{ DHT11_Run(dht11_data);
 288:	ce 01       	movw	r24, r28
 28a:	01 96       	adiw	r24, 0x01	; 1
 28c:	b7 df       	rcall	.-146    	; 0x1fc <DHT11_Run>
		if(dht11_data[4]==(dht11_data[0]+dht11_data[1]+dht11_data[2]+dht11_data[3]))
 28e:	2d 81       	ldd	r18, Y+5	; 0x05
 290:	30 e0       	ldi	r19, 0x00	; 0
 292:	49 81       	ldd	r20, Y+1	; 0x01
 294:	8a 81       	ldd	r24, Y+2	; 0x02
 296:	90 e0       	ldi	r25, 0x00	; 0
 298:	84 0f       	add	r24, r20
 29a:	91 1d       	adc	r25, r1
 29c:	4b 81       	ldd	r20, Y+3	; 0x03
 29e:	84 0f       	add	r24, r20
 2a0:	91 1d       	adc	r25, r1
 2a2:	4c 81       	ldd	r20, Y+4	; 0x04
 2a4:	84 0f       	add	r24, r20
 2a6:	91 1d       	adc	r25, r1
 2a8:	28 17       	cp	r18, r24
 2aa:	39 07       	cpc	r19, r25
 2ac:	09 f0       	breq	.+2      	; 0x2b0 <main+0x4c>
 2ae:	52 c0       	rjmp	.+164    	; 0x354 <main+0xf0>
		{ LCD_Write_String(0,0,"Temperature:");//
 2b0:	40 e6       	ldi	r20, 0x60	; 96
 2b2:	50 e0       	ldi	r21, 0x00	; 0
 2b4:	60 e0       	ldi	r22, 0x00	; 0
 2b6:	80 e0       	ldi	r24, 0x00	; 0
 2b8:	76 df       	rcall	.-276    	; 0x1a6 <LCD_Write_String>
			LCD_Write_NewChar(dht11_data[2]/10%10+0x30);
 2ba:	8b 81       	ldd	r24, Y+3	; 0x03
 2bc:	80 9f       	mul	r24, r16
 2be:	81 2d       	mov	r24, r1
 2c0:	11 24       	eor	r1, r1
 2c2:	86 95       	lsr	r24
 2c4:	86 95       	lsr	r24
 2c6:	86 95       	lsr	r24
 2c8:	80 9f       	mul	r24, r16
 2ca:	91 2d       	mov	r25, r1
 2cc:	11 24       	eor	r1, r1
 2ce:	96 95       	lsr	r25
 2d0:	96 95       	lsr	r25
 2d2:	96 95       	lsr	r25
 2d4:	99 0f       	add	r25, r25
 2d6:	29 2f       	mov	r18, r25
 2d8:	22 0f       	add	r18, r18
 2da:	22 0f       	add	r18, r18
 2dc:	92 0f       	add	r25, r18
 2de:	89 1b       	sub	r24, r25
 2e0:	80 5d       	subi	r24, 0xD0	; 208
 2e2:	56 df       	rcall	.-340    	; 0x190 <LCD_Write_NewChar>
			LCD_Write_NewChar(dht11_data[2]%10+0x30);
 2e4:	8b 81       	ldd	r24, Y+3	; 0x03
 2e6:	80 9f       	mul	r24, r16
 2e8:	91 2d       	mov	r25, r1
 2ea:	11 24       	eor	r1, r1
 2ec:	96 95       	lsr	r25
 2ee:	96 95       	lsr	r25
 2f0:	96 95       	lsr	r25
 2f2:	99 0f       	add	r25, r25
 2f4:	29 2f       	mov	r18, r25
 2f6:	22 0f       	add	r18, r18
 2f8:	22 0f       	add	r18, r18
 2fa:	92 0f       	add	r25, r18
 2fc:	89 1b       	sub	r24, r25
 2fe:	80 5d       	subi	r24, 0xD0	; 208
 300:	47 df       	rcall	.-370    	; 0x190 <LCD_Write_NewChar>
			LCD_Write_String(1,0,"Humidity:");//
 302:	4d e6       	ldi	r20, 0x6D	; 109
 304:	50 e0       	ldi	r21, 0x00	; 0
 306:	60 e0       	ldi	r22, 0x00	; 0
 308:	81 e0       	ldi	r24, 0x01	; 1
 30a:	4d df       	rcall	.-358    	; 0x1a6 <LCD_Write_String>
			LCD_Write_NewChar(dht11_data[0]/10%10+0x30);
 30c:	89 81       	ldd	r24, Y+1	; 0x01
 30e:	80 9f       	mul	r24, r16
 310:	81 2d       	mov	r24, r1
 312:	11 24       	eor	r1, r1
 314:	86 95       	lsr	r24
 316:	86 95       	lsr	r24
 318:	86 95       	lsr	r24
 31a:	80 9f       	mul	r24, r16
 31c:	91 2d       	mov	r25, r1
 31e:	11 24       	eor	r1, r1
 320:	96 95       	lsr	r25
 322:	96 95       	lsr	r25
 324:	96 95       	lsr	r25
 326:	99 0f       	add	r25, r25
 328:	29 2f       	mov	r18, r25
 32a:	22 0f       	add	r18, r18
 32c:	22 0f       	add	r18, r18
 32e:	92 0f       	add	r25, r18
 330:	89 1b       	sub	r24, r25
 332:	80 5d       	subi	r24, 0xD0	; 208
 334:	2d df       	rcall	.-422    	; 0x190 <LCD_Write_NewChar>
			LCD_Write_NewChar(dht11_data[0]%10+0x30);
 336:	89 81       	ldd	r24, Y+1	; 0x01
 338:	80 9f       	mul	r24, r16
 33a:	91 2d       	mov	r25, r1
 33c:	11 24       	eor	r1, r1
 33e:	96 95       	lsr	r25
 340:	96 95       	lsr	r25
 342:	96 95       	lsr	r25
 344:	99 0f       	add	r25, r25
 346:	29 2f       	mov	r18, r25
 348:	22 0f       	add	r18, r18
 34a:	22 0f       	add	r18, r18
 34c:	92 0f       	add	r25, r18
 34e:	89 1b       	sub	r24, r25
 350:	80 5d       	subi	r24, 0xD0	; 208
 352:	1e df       	rcall	.-452    	; 0x190 <LCD_Write_NewChar>
		}
		if(toggle)
 354:	11 23       	and	r17, r17
 356:	31 f0       	breq	.+12     	; 0x364 <main+0x100>
		{ LCD_Write_Char(1,15,0x5c);//显示符号
 358:	4c e5       	ldi	r20, 0x5C	; 92
 35a:	6f e0       	ldi	r22, 0x0F	; 15
 35c:	81 e0       	ldi	r24, 0x01	; 1
 35e:	1b df       	rcall	.-458    	; 0x196 <LCD_Write_Char>
		toggle = 0;}
 360:	10 e0       	ldi	r17, 0x00	; 0
 362:	05 c0       	rjmp	.+10     	; 0x36e <main+0x10a>
		else
		{ LCD_Write_Char(1,15,0x20);//不显示符号
 364:	40 e2       	ldi	r20, 0x20	; 32
 366:	6f e0       	ldi	r22, 0x0F	; 15
 368:	81 e0       	ldi	r24, 0x01	; 1
 36a:	15 df       	rcall	.-470    	; 0x196 <LCD_Write_Char>
			toggle = 1;
 36c:	11 e0       	ldi	r17, 0x01	; 1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 36e:	bf ed       	ldi	r27, 0xDF	; 223
 370:	23 e9       	ldi	r18, 0x93	; 147
 372:	84 e0       	ldi	r24, 0x04	; 4
 374:	b1 50       	subi	r27, 0x01	; 1
 376:	20 40       	sbci	r18, 0x00	; 0
 378:	80 40       	sbci	r24, 0x00	; 0
 37a:	e1 f7       	brne	.-8      	; 0x374 <main+0x110>
 37c:	00 c0       	rjmp	.+0      	; 0x37e <main+0x11a>
 37e:	00 00       	nop
 380:	83 cf       	rjmp	.-250    	; 0x288 <main+0x24>

00000382 <_exit>:
 382:	f8 94       	cli

00000384 <__stop_program>:
 384:	ff cf       	rjmp	.-2      	; 0x384 <__stop_program>
