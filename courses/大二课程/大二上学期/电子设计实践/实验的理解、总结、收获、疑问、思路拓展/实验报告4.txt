实验报告 4.9
PB22061324 张全
1.实验内容：
实验内容1：将INT1管脚上连接的触摸开关的开关次数显
示在一位数码管上(显示在4位七段数码管的任一位即可，
参见PPT“4位共阴极七段数码管的外形和管脚分布“等)
实验内容2：将INT1管脚上的触摸开关的开关次数显示
在四位共阴极七段数码管上
实验内容3：根据小键盘示例和拓展知识等，真正实现
将小键盘最近四次按下的键，按顺序编码并显示在数码
管上
2.实验理解：
(1).#include <avr/io.h>
#include <avr/interrupt.h>
unsigned char counter=0; 
ISR(INT0_vect)//似函数
{ if(counter <4)
counter++;
else counter = 0;
}
int main(void)
{ unsigned char seg7_hex[16]=
{0xfc,0x60,0xda,0xf2,0x66,0xb6,0xbe,0xe0,
0xfe,0xf6,0xee,0x3e,0x9c,0x7a,0x9e,0x8e};//MSB-a,b,…,dp-LSB
DDRB = (0xff);//PB0~7为输出控制七段数码管的a~g,dp
DDRC = (0x01);//PC0为输出控制数码管的共阴极管脚(如'-1’)
PORTC = (0x00);//PC0输出低电平‘0’
DDRD &= ~(1<<DDRD2);//
MCUCR |=((1<<ISC11)|(1<<ISC10));//
GICR |= (1<<INT1);//允许INT1中断
sei(); //开启全局中断SREG(I)
while (1)
{ PORTB = seg7_hex[counter];}
} //main函数结束
(2).#include <avr/io.h>
#define F_CPU 1000000UL
#include <util/delay.h>
#include <avr/interrupt.h>
unsigned int counter=0; //全局变量
ISR(INT1_vect)
{if(counter < 9999) counter++;
else counter = 0; }
int main(void)
{
    /* Replace with your application code */
	unsigned char seg7_hex[16]=
	{0xfc,0x60,0xda,0xf2,0x66,0xb6,0xbe,0xe0,
	0xfe,0xf6,0xee,0x3e,0x9c,0x7a,0x9e,0x8e};//MSB-a,…,g,dp-LSB
	unsigned char i,seg7_com[4]={0xe,0xd,0x0b,0x07};
	unsigned int d_t;
	DDRC = (0x0f);//PC3~0为输出，控制公共端-1,-2,-3,-4
	DDRB = (0xff);//PB7~0为输出，对应控制a,b,...,g,dp段的正极
	DDRD &= ~(1<<DDRD3);//
	MCUCR |=((1<<ISC11)|(1<<ISC10));//
	GICR |= (1<<INT1);//
	sei(); //开启全局中断SREG(I)
    while (1) 
    {
		d_t = counter;
		for(i=0;i<4;i++)
		{ PORTC |=0x0f; //禁止显示
			PORTB =seg7_hex[d_t%10]; //给数
			PORTC =seg7_com[i]; //显示
			d_t=d_t/10; //下一位
			_delay_ms(5);
		}
    }
}
(3).#include <avr/io.h>
unsigned int counter=0;//全局变量
#define F_CPU 1000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
int main(void)
{
   unsigned char seg7_hex[17]={0xfc,0x60,0xda,0xf2,0x66,0xb6,0xbe,0xe0,0xfe,0xf6,0xee,0x3e,0x9c,0x7a,0x9e,0x8e,0x02};//4-7译码
   unsigned char i,seg7_com[4]={0xe,0xd,0x0b,0x07};//扫描码
   unsigned char seg7_no[4]={16,16,16,16};//要显示的4位数字
   unsigned char getkey,keyno;//取扫描输入，对按下按键的编码
   DDRC =(0x0f);//PC3~0输出到公共端-1，-2，-3，-4
   DDRB =(0xff);
   DDRD =(0x0f);
   PORTD =(0xff);
   while(1)
    {
		 /*按键阵列扫描，判断，编码*/
		 keyno = 16;//默认无按键按下
		 //1.扫描第1行
		 PORTD = ~(1<<PORTD0);//PORTD0为低电平，扫描第1行
		 _delay_us(1);
		 getkey = (PIND & 0xf0)>>4;//获取列状态,并移动到低4位
		 switch(getkey)
		 { 
			 case 0x0e:keyno = 1;break;//1行1列为S0
			 case 0x0d:keyno = 2;break;//1行2列为S1
			 case 0x0b:keyno = 3;break;//1行3列为S2
			 case 0x07:keyno = 10;break;//1行4列为S3
		 }
		 //2.扫描第2行
		 PORTD = ~(1<<PORTD1);//PORTD1为低电平，扫描第2行
		 _delay_us(7);
		 getkey = (PIND & 0xf0)>>4;//获取列状态,并移动到低4位
		 switch(getkey)
		 { case 0x0e:keyno = 4;break;
			 //2行1列为S4
			 case 0x0d:keyno = 5;break;
			 //2行2列为S5
			 case 0x0b:keyno = 6;break;
			 //2行3列为S6
			 case 0x07:keyno = 11;break;
			 //2行4列为S7
		 }
		 //3.扫描第3行
		 PORTD = ~(1<<PORTD2);//扫描第3行
		 _delay_us(14);
		 getkey = (PIND & 0xf0)>>4;//获取列状态
		 switch(getkey)
		 { case 0x0e:keyno = 7;break;//3行1列为S8
			 case 0x0d:keyno = 8;break;//3行2列为S9
			 case 0x0b:keyno = 9;break;//…为S10
			 case 0x07:keyno = 12;break;//…为S11
		 }
		 //4.扫描第4行
		 PORTD = ~(1<<PORTD3);//PORTD3为低电平，扫描第4行
		 _delay_us(21);
		 getkey = (PIND & 0xf0)>>4;//获取列状态,并移动到低4位
		 switch(getkey)
		 { case 0x0e:keyno =13;break;//4行1列为S12
			 case 0x0d:keyno =0;break;//4行2列为S13
			 case 0x0b:keyno =14;break;//4行3列为S14
			 case 0x07:keyno =15;break;//4行4列为S15
		 }
		 if(keyno<16) /*扫描一轮并编码后*/
		 { seg7_no[3]=seg7_no[2]; //移动按键数据
			 seg7_no[2]=seg7_no[1];
			 seg7_no[1]=seg7_no[0];
			 seg7_no[0]=keyno; //新的按键数据
		 }
		/*4位七段数码管动态扫描显示*/
		 for(i=0;i<4;i++)
		 {
			 PORTC |= 0x0f; //禁止显示
			 PORTB = seg7_hex[seg7_no[i]];
			 PORTC = seg7_com[i]; //显示
			 _delay_ms(28);
		 }
    }
}
3.实验心得：
(1).注意管脚的连接，在相应的任务中，管脚的连接方式也不同
(2).注意输入与输出的修改，课堂上的PPT使用的例子实施的INT0，而本次实验要求完成INT1，而且管脚有PD2到PD3等变化
(3).在最后一个任务中，首先保证管脚与连线连接正确，否则会出现只显示3个数字等错误情况；其次我们应自行调整A、B、C、D等特殊字符的表示，在16进制内选择合适的数来赋值；最后，为实现4个按键的同时在显示屏上表示，我们可以采用延时与边沿两种方法，此处具体介绍简便的延时处理
即：调整合适的延时效果，可使得4个按键顺序同时出现，经尝试，单位间隔设置为5ms左右较为合适，效果比较明显。


















