PB22061324 张全 5.20

实验内容：
利用ATMEGA8A的ADC测量磁性电阻上的电压,显示在LCD上
利用超声波测量距离并显示在LCD1602上(当距离大于等于10000，显示:NOT Close;当距离小于10000，显示：Close)
用PB3/2/1分别控制RGB LED中的R,G和B正极，实现三种颜色以上的循环亮灭
用PWM控制直流电机的旋转，能调速(由于实验板提供的电压不够，所以改装电线后，利用电脑为其提供较高的电压)

设计思路、代码分析：
将各个功能放在同一个while循环里，把变量均放在一起一次性定义以避免变量的重复定义与定义类型矛盾等问题
将头文件均放在开头(包括延时)，为实现各个功能在一次烧写里实现，我采用了必要的延时以达到缓冲的目的，将各个模块的代码
的while循环部分摘出，有序合理安排到一个while循环中，调整管脚以避免重复
在LCD上显示时，注意调整字符串的位置，以充分利用LCD显示屏，亦可以利用空字符串来美观显示屏的排版分布
在超声波测距时，利用一个if语句，达到距离小于10000单位时显示Close，而距离大于等于10000单位时显示NOT Close
首先引用包括自定义在内的头文件
定义全局变量并初始化ADC，然后开启ADC
进入主函数，首先定义变量
进入LCD功能:TWI_Init(); LCD_Init();
并在进入while循环之前，完成对直流电机的变量处理
进入while循环：
第一个功能：小灯泡的三色循环亮灭，利用延时实现每种颜色的短暂停留(500ms)
先确定相应管脚，接着延时，再用两个并列的for循环实现即可
第二个功能：超声波测距
先处理变量distance，并在LCD第一行显示Distance
进入小的while循环：利用LCD_Write_Char显示距离
利用LCD_Write_String在第二行显示(Not Close)等字样
第三个功能：直流电机的旋转
利用run_stepper实现顺时针与逆时针的旋转，并可以通过管脚PC0来实现转向
利用延时实现电机的周期性旋转
第四个功能：电阻电压显示在LCD的空位
while(adc_result>0 && dh<7)//三位小数
		{
			adc_result *=10;//第一位小数调整到整数
			uc_int = (unsigned char) adc_result;//取整数
			adc_result -=uc_int; //剩下的小数部分
			uc_display[dh++]=uc_int+0x30; //当前的小数为转换为字符以显示
		}
while循环将小数部分转换为字符
利用LCD_Write_String将转化后得到的字符显示在LCD第二行空白处


实验结果：
灯泡实现3中颜色的循环亮灭，每种颜色因为延时功能，停留一段时间
超声波测量距离并显示在LCD1602上(当距离大于等于10000，显示:NOT Close;当距离小于10000，显示：Close)
电阻的电压显示在LCD上
直流电机由笔记本供电，实现旋转，并可以通过管脚的连接方式实现旋转方向的改变(由于延时功能的存在，旋转呈周期性变化)


实验代码：
主函数：
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#define F_CPU 1000000UL
#include "twi_lcd.h"
#include "hc_sr04.h"
#include "m_28byj48.h"
void ADC_Init(unsigned char adc_ch)//ADC初始化，低4bit,adc0~7:0~7
{ ADMUX = (1<<REFS0)|(adc_ch & 0x0f);//参考电压：AVCC，低4bit为通道选择
	ADCSRA = (1<<ADEN)|(1<<ADFR)|(1<<ADPS1)|(1<<ADPS0);//开启ADC，连续模式,右对齐，
	//预分频8，1000/8=125kHz
	ADCSRA |=(1<<ADSC);//ADC开始转换
}
int main(void)
{
	unsigned int distance=0;
	unsigned char i=15,uc_d=0,j=0;
	unsigned int n,m;
	unsigned int high,low,y;
	TWI_Init(); LCD_Init();
    DDRD |= (1<<DDRD2)|(1<<DDRD1)|(1<<DDRD0);
	DDRD &=~(1<<DDRD0);//输入：通过PD0连接到电源正极或负极进行正反转选择
	PORTD |=(1<<PORTD0); //内部上拉
	unsigned char adc_dh,adc_dl;
	//用于存储adch/l寄存器里的数据
	float adc_result;//adc采集结果
	unsigned char dh,uc_int,uc_display[8];//临时变量
	LCD_Init();
	ADC_Init(6); //初始化adc，对ADC6（PC6）采样，参考电压…
    while (1)
    { 
		PORTD = (1<<PORTD2);//only red on
	    _delay_ms(500);
	    for(n=0;n<100;n++)
	    for(m=0;m<1000;m++);
	    PORTD = (1<<PORTD1);//only green on
	    _delay_ms(500);
	    for(n=0;n<100;n++)
	    for(m=0;m<1000;m++);
	    PORTD = (1<<PORTD0);//only blue on
	    _delay_ms(500);
	    for(n=0;n<100;n++)
	    for(m=0;m<1000;m++);
		distance = HCSR04_Run();
		LCD_Write_String(0,0,"Distance:");
		i=15; //从最低位开始转换和显示，最多7位
		while(distance>0)
		{ uc_d = distance % 10+0x30;
			LCD_Write_Char(0,i,uc_d);
			if(distance<10000)
			LCD_Write_String(1,4,"Close");
			else
			LCD_Write_String(1,0,"NOT");
		i--; distance /=10;}
		while(i>8) //高位没有数字时不显示
		{ 
			LCD_Write_Char(0,i,0x20);i--;
		}
		_delay_ms(100);
		if(PIND & (1<<PIND0))
		run_stepper(0,1,4096);
		//8拍驱动方式，顺时针，转动一周
		else
		run_stepper(0,0,4096);
		//8拍驱动方式，逆时针，转动一周
		while(!(ADCSRA & (1<<ADIF)));//等待ADC转换结束
		adc_dl = ADCL;//先读低8位
		adc_dh = ADCH;//再读高8位
		adc_result = adc_dh *256.0+adc_dl;//合并
		adc_result *=5.0/1024.0;//计算电压
		for(dh=0;dh<8;dh++)//初始化显示变量，都不显示
		{ uc_display[dh]=0x20; }
		uc_int = (unsigned char) adc_result;//取整数
		adc_result -=uc_int;//取小数
		dh=2;//整数占2位
		uc_display[3]=0x30;//初始整数为0
		while(uc_int > 0 && dh >0)
		{ uc_display[dh--]=uc_int%10+0x30;//最低位数字转换成字符
		uc_int/=10;/*去掉整数的最低位*/}
		uc_display[3]='.';//小数点
		dh=4; //小数从元素4开始存储
		while(adc_result>0 && dh<7)//三位小数
		{
			adc_result *=10;//第一位小数调整到整数
			uc_int = (unsigned char) adc_result;//取整数
			adc_result -=uc_int; //剩下的小数部分
			uc_display[dh++]=uc_int+0x30; //当前的小数为转换为字符以显示
		}
		uc_display[7]=0; //字符结束
		LCD_Write_String(1,9,uc_display); //显示采集转换后的电压数值
		_delay_us(300);
    }
}
头文件：
1.#ifndef HC_SR04_H_
#define HC_SR04_H_
#ifndef F_CPU
#define F_CPU 1000000UL
#endif
#include <avr/io.h>
#include <util/delay.h>
unsigned int HCSR04_Run(void)
{ unsigned int i_cnt=0;//统计echo的高电平(固定时钟下的次数)
	unsigned int uc_cnt=1;//超时计数（统计在一定时间内没有响应）
	/*为了测量的准确，如系统中使用了中断，这里要禁止中断 cli(); */
	DDRD |= (1<<DDRD6);//PD6为输出（到HC_SR04的Trig管脚）
	DDRD &= ~(1<<DDRD5);//PD5为输入（来自HC_SR04的Echo管脚）
	PORTD |=(1<<PORTD6);//PD6输出高电平到Trig告诉HC_SR04准备发送超声波
	_delay_us(20);//持续20us(>10us)
	PORTD &=~(1<<PORTD6);//PD6输出低电平到Trig结束通知
	while((PIND&(1<<PIND5))==0) //等待Echo为高电平(即收到超声回波)
	{ uc_cnt++; if(uc_cnt>9000)break;//计数溢出：超时，跳过
	}
	i_cnt = 2;//统计Echo的初值=检测到echo信号+循环的判断约2个CPU时钟周期
	while((PIND&(1<<PIND5))!=0)//继续统计ECHO信号高电平的持续时间
	i_cnt++;//每次=数据加载+&运算+判断+循环+加约5个时钟周期（默认1MHz）
	/*若之前禁用了中断，这里可以开中断了 sei();*/
	return(i_cnt*5.0/100.0*17.0);//返回距离，单位mm
}
#endif /* HC_SR04_H_ */
2.#ifndef M_28BYJ48_H_
#define M_28BYJ48_H_
#ifndef F_CPU
#define F_CPU 1000000UL/*<util/delay.h>需要定义F_CPU参数*/
#endif
#include <util/delay.h> //包含延时函数_delay_ms()和_delay_us()等
#include <avr/io.h>
/* 3种不同驱动方式下28byj48步进电机的控制信号，脉冲数据
* 低4位中bit3控制28byj48的蓝色线(D),bit2-粉(C),bit1-黄(B),bit0-橙(A)*/
const unsigned char
stepper_ph[3][8]={{0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09},//混合8拍
{0x03,0x06,0x0C,0x09},//双4拍
{0x01,0x02,0x04,0x08}};//单4拍
unsigned char stepper_index = 0;//记录并控制步进电机的步伐
/* 28BYJ-48步进电机的控制函数，其参数的作用为：
* phase:选择步进电机的驱动方式，0：8拍，1：双4拍，2：单4拍
* dir:步进电机的转动方向，0：顺时针，1：逆时针
* step:控制步进电机转动多少步（多少个脉冲），0~65535*/
void run_stepper(unsigned char phase,unsigned char dir,unsigned int step)
{ unsigned char ph = phase ? 0x03:0x07;//驱动方式，确定脉冲的选择增量
	unsigned char inc = dir ?0x01:ph; /*逆时针增量为1，顺时针 4拍为3,8拍为7*/
	unsigned int i;//定义循环变量i
	DDRC |=(1<<DDRC3)|(1<<DDRC2)|(1<<DDRC1)|(1<<DDRC0);//PC输出
	for(i=0;i<step;i++)//输出step个脉冲步
	{ stepper_index += inc;//通过增量调整，不断地切换输出脉冲
		stepper_index &= ph; //去掉递增后的无效高位值
		PORTC &=0xf0; //选择相应的控制脉冲通过端口C进行输出
		PORTC |= stepper_ph[phase][stepper_index];
		_delay_us(900);//8拍 _delay_us(1600);//双4拍//_delay_us(2000);//单四拍
	} }
	#endif /* M_28BYJ48_H_ */
3.#ifndef TWI_FUN_H_
#define TWI_FUN_H_
#include <util/twi.h>//软件自带TWI接口的寄存器等头文件
void TWI_Init(void)//twi 接口的初始化
{//设置SCL的频率：1MHz cpu-50KHz scl,2M-100K,8M-400K
	TWSR = 0x00; //最低2位为预分频设置(00-1,01-4,10-16,11-64)
	TWBR = 0x02; //位率设置，fscl=cpu频率/(16+2*TWBR*预分频值)
	TWCR = (1<<TWEN); //开启TWI
}
void TWI_Start(void)//发送Start信号，开始本次TWI通信
{ TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);//发送Start信号
	while(!(TWCR &(1<<TWINT)));//等待Start信号发出
}
void TWI_Stop(void)//发送Stop信号，结束本次TWI通信
{ TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);//发送Stop信号
}
void TWI_Write(unsigned char uc_data) //向TWI接口发送8位数据
{
	TWDR = uc_data;//8位数据存放在TWDR
	TWCR = (1<<TWINT)|(1<<TWEN);//发送TWDR中的数据
	while(!(TWCR &(1<<TWINT)));//等待数据发出
}
unsigned char TWI_Read_With_ACK(void)
{
	TWCR = (1<<TWINT)|(1<<TWEA)|(1<<TWEN);//准备接收数据，并ACK
	while(!(TWCR &(1<<TWINT)));//等待接收数据
	return TWDR;//返回接收到的数据
}
unsigned char TWI_Read_With_NACK(void)
{
	TWCR = (1<<TWINT)|(1<<TWEN);//准备接收数据，并NACK
	while(!(TWCR &(1<<TWINT)));//等待接收数据
	return TWDR;//返回接收到的数据
}unsigned char TWI_Get_State_Info(void)
{
	unsigned char uc_status;
	uc_status = TWSR & 0xf8;
	return uc_status;
}
#endif /* TWI_FUN_H_ */
4.#ifndef TWI_LCD_H_
#define TWI_LCD_H_
#ifndef F_CPU
#define F_CPU 1000000UL //延时用
#endif
#include "twi_fun.h"
#include <util/delay.h>
//LCD1602 控制和显示指令
#define LCD_CLEARDISPLAY 0x01//清屏，设置AC为DDRAM地址0
#define LCD_RETURNHOME 0x02//设置AC为DDRAM地址0，光标回原点
#define LCD_ENTRYMODESET 0x04//与I/D和S位定义光标移动方向和显示移位
#define LCD_DISPLAYCONTROL 0x08//与D/C/B设置显示开关，光标开关/闪烁
#define LCD_CURSORSHIFT 0x10//与S/C和R/L一起设置光标移动或显示移位
#define LCD_FUNCTIONSET 0x20//与DL、N和F一起设置LCD功能:8/4位数
//据;1/2行显示;5*8/10点阵字符
#define LCD_SETCGRAMADDR 0x40//设置CGRAM地址到地址计数器(AC）
#define LCD_SETDDRAMADDR 0x80//设置DDRAM地址到地址计数器(AC）
// LCD进入模式设置位(LCD_ENTRYMODESET=0x04)
#define LCD_ENTRYSHIFT 0x01//S位=1，显示移位，=0不移位
#define LCD_ENTRYINC 0x02//I/D位=1，显示左移(递增)
//LCD显示开关控制位 (LCD_DISPLAYCONTROL=0x08)
#define LCD_BLINKON 0x01//B=1，闪烁
#define LCD_CURSORON 0x02//C=1，光标
#define LCD_DISPLAYON 0x04//D=1，显示开
//LCD光标和显示移位控制位(LCD_CURSORSHIFT=0x10)
#define LCD_CURSOR2LEFT 0x00//S/C=0,R/L=0:光标往左移
#define LCD_CURSOR2RIGHT 0x04//S/C=0,R/L=1:光标往右移
#define LCD_DC2LEFT 0x08//S/C=1,R/L=0:显示向左移，光标跟着移
#define LCD_DC2RIGHT 0x0C//S/C=1,R/L=1:显示向右移,光标跟着移
//LCD功能设置位(LCD_FUNCTIONSET=0x20)
#define LCD_4BITMODE 0x00 //DL=0:4位(DB7-4)数据，需2次传输
#define LCD_8BITMODE 0x10 //DL=1：8位(DB7-0)数据传输
#define LCD_1LINE 0x00 //N=0，1行显示
#define LCD_2LINE 0x08 //N=1，2行显示
#define LCD_5X8DOTS 0x00 //F=0：5X8 dots字符
#define LCD_5XADOTS 0x04 //F=1：5X10 dots字符，只能1行显示
//LCD 1602 控制管脚：I2C数据的低4位（PCF8574-P0~3)
#define LCD_RS 0x01 //PCF8574-P0控制LCD1602的RS管脚
#define LCD_RW 0x02 //PCF8574-P1）控制LCD1602的RW管脚
#define LCD_E 0x04 //PCF8574-P2）控制LCD1602的E管脚
#define LCD_BACKLIGHTON 0x08 //PCF8574-P3控制LCD1602的K管脚
#define LCD_SLAVE_ADDRESS 0x27 //从机地址PCF8574(A2-0:111)
unsigned char TWI_Write_LCD(unsigned char uc_data)
{ TWI_Start();//发送START信号
	if(TWI_Get_State_Info()!=TW_START) return 0;//不成功
	TWI_Write(LCD_SLAVE_ADDRESS<<1|TW_WRITE); //发送SLA+W
	if(TWI_Get_State_Info()!=TW_MT_SLA_ACK)return 0;//不成功
	TWI_Write(uc_data|LCD_BACKLIGHTON);//发送数据+背光常开
	if(TWI_Get_State_Info()!=TW_MT_DATA_ACK)return 0;//不成功
	TWI_Stop();
	return 1;//成功
}
void LCD_4Bit_Write(unsigned char uc_data)//4位方式写PCF8574
{ TWI_Write_LCD(uc_data);//数据送出，E=0
	_delay_us(1);//保持
	TWI_Write_LCD(uc_data|LCD_E);//数据送出，E=1
	_delay_us(1);//保持
	TWI_Write_LCD(uc_data & (~LCD_E));//数据送出，E=0
	_delay_us(50);//等待数据传输结束
}
void LCD_8Bit_Write(unsigned char uc_data,unsigned char uc_mode)
//2次4位数据传输方式写PCF9574,uc_mode:0-命令,1-数据
{ unsigned char high4bit = uc_data & 0xf0;
	unsigned char low4bit = (uc_data<<4)&0xf0;
	LCD_4Bit_Write(high4bit|uc_mode);//先发送高4位
	LCD_4Bit_Write(low4bit|uc_mode);//再发送低4位
}
void LCD_Init()//初始化LCD1602
{ _delay_ms(50);//上电后至少再等40ms
	LCD_4Bit_Write(0x30); //在默认8位接口，试着进入4位接口模式
	_delay_us(4500);//等待至少4.5ms
	LCD_4Bit_Write(0x30); _delay_us(4500);//等待至少4.5ms
	LCD_4Bit_Write(0x30); _delay_us(150);//等待至少150us
	LCD_4Bit_Write(0x20);//进入4位接口模式
	//设置模式，显示，点数等
	LCD_8Bit_Write(LCD_FUNCTIONSET|LCD_4BITMODE|LCD_2LINE|LCD_5X8DOTS,
	0);
	LCD_8Bit_Write(LCD_DISPLAYCONTROL|LCD_DISPLAYON,0);//显示
	LCD_8Bit_Write(LCD_CLEARDISPLAY,0); _delay_us(2000);//等待
	LCD_8Bit_Write(LCD_ENTRYMODESET|LCD_ENTRYINC,0);//显示左移(递增)
	LCD_8Bit_Write(LCD_RETURNHOME,0);//返回原点
	_delay_us(2000);//等待
}
void LCD_Set_Cursor_Location(unsigned char row,unsigned char col)
//设置光标位置,row:0~1,col:0~39
{ unsigned char offset[]={0x0,0x40}; LCD_8Bit_Write(LCD_SETDDRAMADDR|(col+offset[row]),0);
}
void LCD_Write_NewChar(char c_data)//在当前位置显示
{ LCD_8Bit_Write(c_data,1);
}
void LCD_Write_Char(unsigned char row,unsigned char col,char c_data)
//在指定位置显示
{ LCD_Set_Cursor_Location(row,col); LCD_8Bit_Write(c_data,1);
}
void LCD_Write_String(unsigned char row,unsigned char col,const char *pStr)
//在指定位置显示串
{
	LCD_Set_Cursor_Location(row,col);
	while((*pStr) != '\0')
	{
		LCD_8Bit_Write(*pStr,1);
		pStr ++;
	}
}
#endif /* TWI_LCD_H_ */

3.实验总结：
难点:
管脚的改变与变换，课堂上的PPT的管脚大多是重复的，需要自行改变改变管脚，否则会出现元器件之间相互影响而导致出现显示问题的情况

变量的重复：PPT大多采用变量i,我们需要采用新的变量名，以防止对同一个变量反复定义，以及变量类型定义矛盾的情况

解决whille(1)问题：在进行多个功能的实现时，不同模块的while(1)可能会造成死循环，从而导致下一个循环无法正常进行，此时我们需要把不同功能写进同一个while(1)里，亦或是在前一个while(1)里定义变量flag已达到跳出上一个循环，进入下一个循环的效果

头文件的引用：在实现不同模块功能的同时，我们要注意个模块头文件的引用得当：
如：#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#define F_CPU 1000000UL
#include "twi_lcd.h"
#include "hc_sr04.h"
#include "m_28byj48.h"

注意尽量不要使用全局变量，否则在实现不同功能时可能会通过全局变量相互影响





